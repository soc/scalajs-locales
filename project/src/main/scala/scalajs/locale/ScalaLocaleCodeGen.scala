package scalajs.locale

import java.io.{File, FileInputStream, InputStreamReader}
import java.nio.charset.Charset
import java.nio.file.Files
import java.util.function.IntPredicate
import javax.xml.parsers.SAXParserFactory

import scala.xml.{XML, _}
import scala.collection.JavaConverters._
import scala.collection.breakOut

/**
  * Value objects build out of CLDR XML data
  */
case class NumericSystem(id: String, digits: String)

case class NumberSymbols(system: NumericSystem,
    aliasOf: Option[NumericSystem] = None,
    decimal: Option[Char] = None,
    group: Option[Char] = None,
    list: Option[Char] = None,
    percent: Option[Char] = None,
    plus: Option[Char] = None,
    minus: Option[Char] = None,
    perMille: Option[Char] = None,
    infinity: Option[String] = None,
    nan: Option[String] = None,
    exp: Option[String] = None)

object NumberSymbols {
  def alias(system: NumericSystem, aliasOf: NumericSystem): NumberSymbols =
    NumberSymbols(system, aliasOf = Some(aliasOf))
}

case class XMLLDMLLocale(language: String, territory: Option[String],
    variant: Option[String], script: Option[String])

case class XMLLDML(locale: XMLLDMLLocale, defaultNS: Option[NumericSystem],
                   digitSymbols: Map[NumericSystem, NumberSymbols]) {
  val scalaSafeName: String = {
    List(Some(locale.language), locale.script, locale.territory, locale.variant)
      .flatten.mkString("_")
  }
}

object CodeGenerator {
  import treehugger.forest._
  import definitions._
  import treehuggerDSL._

  val autoGeneratedCommend = "Auto-generated code from CLDR definitions, don't edit"

  def buildClassTree(packageObject: String, ldmls: List[XMLLDML],
      only: List[String]): Tree = {
    val langs = ldmls.map(_.scalaSafeName.split("_").toList)
    // Root must always be available
    val root = ldmls.find(_.scalaSafeName == "root").get

    val objectBlock = if (only.nonEmpty) {
       ldmls.filter(a => only.contains(a.scalaSafeName))
        .map(buildClassTree(root, langs))
      } else {
        ldmls.map(buildClassTree(root, langs))
      }

    BLOCK (
      List(IMPORT("scala.scalajs.locale.cldr.LDML") withComment autoGeneratedCommend,
      IMPORT("scala.scalajs.locale.cldr.LDMLLocale"),
      IMPORT("scala.scalajs.locale.cldr.Symbols"),
      IMPORT("scala.scalajs.locale.cldr.data.numericsystems._")) ++ objectBlock
    ) inPackage "scala.scalajs.locale.cldr.data"
  }

  def findParent(root: XMLLDML, langs: List[List[String]],
      ldml: XMLLDML): Option[String] = {
    // http://www.unicode.org/reports/tr35/#Locale_Inheritance

    // This searches based on the simple hierarchy resolution based on bundle_name
    // http://www.unicode.org/reports/tr35/#Bundle_vs_Item_Lookup
    ldml.scalaSafeName.split("_").reverse.toList match {
      case x :: Nil if x == root.scalaSafeName => None
      case x :: Nil => Some(root.scalaSafeName)
      case x :: xs if langs.contains(xs.reverse) => Some(xs.reverse.mkString("_"))
    }
  }

  def buildClassTree(root: XMLLDML, langs: List[List[String]])
      (ldml: XMLLDML): Tree = {
    val ldmlSym = getModule("LDML")
    val ldmlNumericSym = getModule("Symbols")
    val ldmlLocaleSym = getModule("LDMLLocale")

    val parent = findParent(root, langs, ldml).fold(NONE)(v => SOME(REF(v)))

    val ldmlLocaleTree = Apply(ldmlLocaleSym, LIT(ldml.locale.language),
      ldml.locale.territory.fold(NONE)(t => SOME(LIT(t))),
      ldml.locale.variant.fold(NONE)(v => SOME(LIT(v))),
      ldml.locale.script.fold(NONE)(s => SOME(LIT(s))))

    val defaultNS = ldml.defaultNS.fold(NONE)(s => SOME(REF(s.id)))

    // Locales only use the default numeric system
    val numericSymbols = ldml.digitSymbols.map { case (ns, symb) =>
      val decimal = symb.decimal.fold(NONE)(s => SOME(LIT(s)))
      val group = symb.group.fold(NONE)(s => SOME(LIT(s)))
      val list = symb.list.fold(NONE)(s => SOME(LIT(s)))
      val percent = symb.percent.fold(NONE)(s => SOME(LIT(s)))
      val minus = symb.minus.fold(NONE)(s => SOME(LIT(s)))
      val perMille = symb.perMille.fold(NONE)(s => SOME(LIT(s)))
      val infinity = symb.infinity.fold(NONE)(s => SOME(LIT(s)))
      val nan = symb.nan.fold(NONE)(s => SOME(LIT(s)))
      val exp = symb.exp.fold(NONE)(s => SOME(LIT(s)))
      Apply(ldmlNumericSym, REF(ns.id),
        symb.aliasOf.fold(NONE)(n => SOME(REF(n.id))), decimal, group, list,
        percent, minus, perMille, infinity, nan, exp)
    }

    OBJECTDEF(ldml.scalaSafeName) withParents Apply(ldmlSym, parent, ldmlLocaleTree, defaultNS, LIST(numericSymbols))

  }

  def metadata(codes: List[String], languages: List[String], scripts: List[String]): Tree = {
    BLOCK (
      OBJECTDEF("metadata") := BLOCK(
        LAZYVAL("isoCountries", "Array[String]") :=
          ARRAY(codes.map(LIT(_))) withComment autoGeneratedCommend,
        LAZYVAL("isoLanguages", "Array[String]") :=
          ARRAY(languages.map(LIT(_))) withComment autoGeneratedCommend,
        LAZYVAL("scripts", "Array[String]") :=
          ARRAY(scripts.map(LIT(_))) withComment autoGeneratedCommend
      )
    ) inPackage "scala.scalajs.locale.cldr.data"
  }

  def numericSystems(ns: Seq[NumericSystem]): Tree = {
    val ldmlNS = getModule("NumberingSystem")

    BLOCK (
      IMPORT("scala.scalajs.locale.cldr.NumberingSystem") withComment autoGeneratedCommend,
      OBJECTDEF("numericsystems") := BLOCK(
        ns.map(s =>
          LAZYVAL(s.id, "NumberingSystem") :=
            Apply(ldmlNS, LIT(s.id), LIST(s.digits.toList.map(LIT(_))))
        )
      )
    ) inPackage "scala.scalajs.locale.cldr.data"
  }

}

object ScalaLocaleCodeGen {
  def writeGeneratedTree(base: File, file: String, tree: treehugger.forest.Tree):File = {
    val dataPath = base.toPath.resolve("scala").resolve("sacalajs")
      .resolve("cldr").resolve("data")
    val path = dataPath.resolve(s"$file.scala")

    path.getParent.toFile.mkdirs()
    println(s"Write to $path")

    //println(treehugger.forest.treeToString(tree))

    Files.write(path, treehugger.forest.treeToString(tree)
      .getBytes(Charset.forName("UTF8")))
    path.toFile
  }

  val unicodeIgnorable = new IntPredicate {
    override def test(value: Int): Boolean = !Character.isIdentifierIgnorable(value)
  }

  /**
    * Parse the xml into an XMLLDML object
    */
  def constructLDMLDescriptor(f: File, xml: Elem, latn: NumericSystem,
      ns: Map[String, NumericSystem]): XMLLDML = {
    // Parse locale components
    val language = (xml \ "identity" \ "language" \ "@type").text
    val territory = Option((xml \ "identity" \ "territory" \ "@type").text)
      .filter(_.nonEmpty)
    val variant = Option((xml \ "identity" \ "variant" \ "@type").text)
      .filter(_.nonEmpty)
    val script = Option((xml \ "identity" \ "script" \ "@type").text)
      .filter(_.nonEmpty)

    // Find out the default numeric system
    val defaultNS = Option((xml \ "numbers" \ "defaultNumberingSystem").text)
      .filter(_.nonEmpty).filter(ns.contains)
    def symbolS(n: NodeSeq): Option[String] = if (n.isEmpty) None else Some(n.text)

    def symbolC(n: NodeSeq): Option[Char] = if (n.isEmpty) None else {
      // Filter out the ignorable code points, e.g. RTL and LTR marks
      val charInt = n.text.codePoints().filter(unicodeIgnorable).findFirst().orElse(0)
      Some(charInt.toChar)
    }

    val symbols = (xml \ "numbers" \\ "symbols").flatMap { s =>
      // http://www.unicode.org/reports/tr35/tr35-numbers.html#Numbering_Systems
      // By default, number symbols without a specific numberSystem attribute
      // are assumed to be used for the "latn" numbering system, which i
      // western (ASCII) digits
      val nsAttr = Option((s \ "@numberSystem").text).filter(_.nonEmpty)
      val sns = nsAttr.flatMap(ns.get).getOrElse(latn)
      // TODO process aliases
      val nsSymbols = s.collect {
        case s @ <symbols>{_*}</symbols> if (s \ "alias").isEmpty =>
          // elements may not be present and they could be the empty string
          val decimal = symbolC(s \ "decimal")
          val group = symbolC(s \ "group")
          val list = symbolC(s \ "list")
          val percentSymbol = symbolC(s \ "percentSign")
          val plusSign = symbolC(s \ "plusSign")
          val minusSign = symbolC(s \ "minusSign")
          val perMilleSign = symbolC(s \ "perMille")
          val infiniteSign = symbolS(s \ "infinity")
          val nan = symbolS(s \ "nan")
          val exp = symbolS(s \ "exponential")
          val sym = NumberSymbols(sns, None, decimal, group, list,
            percentSymbol, plusSign, minusSign, perMilleSign, infiniteSign, nan, exp)
          sns -> sym

        case s @ <symbols>{_*}</symbols> =>
          // We take advantage that all aliases on CLDR are to latn
          sns -> NumberSymbols.alias(sns, latn)
      }
      nsSymbols
    }
    XMLLDML(XMLLDMLLocale(language, territory, variant, script),
      defaultNS.flatMap(ns.get), symbols.toMap)
  }

  // Note this must be a def or there could be issues with concurrency
  def parser: SAXParser = {
    val f = SAXParserFactory.newInstance()
    // Don't validate to speed up generation
    f.setNamespaceAware(false)
    f.setValidating(false)
    f.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
    f.newSAXParser()
  }

  def parseNumberingSystems(xml: Elem): Seq[NumericSystem] = {
    val ns = xml \ "numberingSystems" \\ "numberingSystem"

    for {
      n <- ns
      if (n \ "@type").text == "numeric" // ignore algorithmic ns
    } yield {
      val id = (n \ "@id").text
      val digits = (n \ "@digits").text
      NumericSystem(id, digits)
    }
  }

  def readNumericSystems(data: File): Seq[NumericSystem] = {
    // Parse the numeric systems
    val numberingSystemsFile = data.toPath.resolve("common")
      .resolve("supplemental").resolve("numberingSystems.xml").toFile
    val numericSystems = parseNumberingSystems(XML.withSAXParser(parser)
      .loadFile(numberingSystemsFile))
    numericSystems
  }

  def generateNumericSystemsFile(base: File, numericSystems: Seq[NumericSystem]): File = {
    // Generate numeric systems source code
    writeGeneratedTree(base, "numericsystems",
      CodeGenerator.numericSystems(numericSystems))
  }

  def buildLDMLDescriptors(data: File, numericSystemsMap: Map[String, NumericSystem],
                           latnNS: NumericSystem): List[XMLLDML] = {
    // All files under common/main
    val files = Files.newDirectoryStream(data.toPath.resolve("common")
      .resolve("main")).iterator().asScala.toList

    for {
      f <- files.map(k => k.toFile)
      r = new InputStreamReader(new FileInputStream(f), "UTF-8")
    } yield constructLDMLDescriptor(f, XML.withSAXParser(parser).load(r),
      latnNS, numericSystemsMap)
  }

  def generateLocalesFile(base: File, clazzes: List[XMLLDML]): File = {
    val names = clazzes.map(_.scalaSafeName)

    // Generate locales code
    val stdTree = CodeGenerator.buildClassTree("data", clazzes, names)
    writeGeneratedTree(base, "data", stdTree)
  }

  def generateMetadataFile(base: File, clazzes: List[XMLLDML]): File = {
    val isoCountryCodes = clazzes.flatMap(_.locale.territory).distinct
      .filter(_.length == 2).sorted
    val isoLanguages = clazzes.map(_.locale.language).distinct
      .filter(_.length == 2).sorted
    val scripts = clazzes.flatMap(_.locale.script).distinct.sorted
    // Generate metadata source code
    writeGeneratedTree(base, "metadata",
      CodeGenerator.metadata(isoCountryCodes, isoLanguages, scripts))
  }

  def generateDataSourceCode(base: File, data: File): Seq[File] = {
    val nanos = System.nanoTime()
    val numericSystems = readNumericSystems(data)
    val f1 = generateNumericSystemsFile(base, numericSystems)

    val numericSystemsMap: Map[String, NumericSystem] =
      numericSystems.map(n => n.id -> n)(breakOut)
    // latn NS must exist, break if not found
    val latnNS = numericSystemsMap.get("latn").get

    val ldmls = buildLDMLDescriptors(data, numericSystemsMap, latnNS)

    val f2 = generateMetadataFile(base, ldmls)
    val f3 = generateLocalesFile(base, ldmls)

    println("Generation took " + (System.nanoTime() - nanos) / 1000000 + " [ms]")
    Seq(f1, f2, f3)
  }
}
